<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>Rose 3D</title>
  <link href="https://fonts.googleapis.com/css2?family=Niconne&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@500&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    body {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: radial-gradient(circle, #82707a, #24111e 100%);
      overflow: hidden;
    }
    main {
      position: relative;
      z-index: 1;
    }
    h1 {
      font-family: "Niconne", cursive;
      font-size: 10vw;
      margin-left: 1rem;
      color: rgba(255, 255, 255, 0.2);
    }
    p {
      position: fixed;
      bottom: 0;
      margin: 10px;
      font-size: max(3.3vw, 15px);
      color: rgba(255, 255, 255, 0.5);
    }
    #filter {
    }
    canvas {
      -moz-user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
      position: fixed;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      margin: 0;
      padding: 0;
      z-index: 1;
    }
    #rain-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      pointer-events: none;
      z-index: 0;
    }
    .rain-text {
      position: absolute;
      font-family: 'Dancing Script', cursive;
      color: rgba(255, 220, 220, 0.85);
      white-space: nowrap;
      text-shadow: 0 0 15px rgba(255, 50, 50, 0.5), 0 0 30px rgba(255, 100, 100, 0.3);
      top: -60px;
    }
    @keyframes fall {
      0% {
        transform: translateY(0);
        opacity: 0;
      }
      5% {
        opacity: 1;
      }
      95% {
        opacity: 1;
      }
      100% {
        transform: translateY(calc(100vh + 120px));
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <div id="rain-container"></div>
  <main>
    <h1></h1>
    <p></p>
  </main>
  <div id="filter"></div>

  <script>
    // Rain text effect
    const phrases = ['mi amor', "je t'aime"];
    const rainContainer = document.getElementById('rain-container');
    
    function createRainDrop() {
      const text = document.createElement('div');
      text.className = 'rain-text';
      text.textContent = phrases[Math.floor(Math.random() * phrases.length)];
      
      text.style.left = Math.random() * 100 + '%';
      text.style.fontSize = (Math.random() * 24 + 24) + 'px';
      
      const duration = Math.random() * 8 + 8; // 8-16 seconds
      text.style.animation = `fall ${duration}s linear forwards`;
      
      rainContainer.appendChild(text);
      
      // Remove after animation completes
      setTimeout(() => {
        text.remove();
      }, (duration + 2) * 1000);
    }
    
    // Create initial batch
    for (let i = 0; i < 15; i++) {
      setTimeout(createRainDrop, i * 200);
    }
    
    // Keep creating new drops
    setInterval(createRainDrop, 600);
  </script>

  <script src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    /*
    Rose 3D
    https://codepen.io/wakana-k/pen/LYgREZb
    */

    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { OBJLoader } from "three/addons/loaders/OBJLoader.js";

    let container;
    let camera, scene, renderer, controls;
    let manager;
    let object;
    let material = new THREE.MeshStandardMaterial({
      metalness: 0,
      roughness: 0.8,
      side: THREE.DoubleSide
    });

    init();
    animate();

    function init() {
      container = document.createElement("div");
      document.body.appendChild(container);

      camera = new THREE.PerspectiveCamera(
        33,
        window.innerWidth / window.innerHeight,
        1,
        2000
      );
      camera.position.y = 80;
      camera.position.z = 650;

      // scene
      scene = new THREE.Scene();

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);

      const pointLight = new THREE.PointLight(0xffffff, 0.8);
      pointLight.castShadow = true;
      camera.add(pointLight);
      scene.add(camera);

      // Create pedicle (stem)
      function createPedicle(length = 120) {
        const stemGroup = new THREE.Group();
        
        // Main stem material
        const stemMaterial = new THREE.MeshStandardMaterial({
          color: 0x2d5a27,
          roughness: 0.8,
          metalness: 0
        });

        // Main stem - slightly curved using multiple segments
        const stemLength = length;
        const stemSegments = 8;
        const segmentLength = stemLength / stemSegments;
        
        for (let i = 0; i < stemSegments; i++) {
          const topRadius = 2.5 - (i * 0.15);
          const bottomRadius = 2.5 - ((i + 1) * 0.15);
          const segment = new THREE.CylinderGeometry(
            Math.max(topRadius, 1.2),
            Math.max(bottomRadius, 1.2),
            segmentLength,
            12
          );
          const segmentMesh = new THREE.Mesh(segment, stemMaterial);
          
          segmentMesh.position.set(
            0,
            -25 - (i * segmentLength),
            0
          );
          segmentMesh.castShadow = true;
          segmentMesh.receiveShadow = true;
          stemGroup.add(segmentMesh);
        }

        // Add thorns
        const thornMaterial = new THREE.MeshStandardMaterial({
          color: 0x3d6a37,
          roughness: 0.6,
          metalness: 0
        });

        const thornPositions = [
          { y: -40, rotZ: 0.5, rotY: 0 },
          { y: -60, rotZ: -0.5, rotY: Math.PI * 0.6 },
          { y: -80, rotZ: 0.5, rotY: Math.PI * 1.2 },
          { y: -100, rotZ: -0.5, rotY: Math.PI * 1.8 },
        ];

        thornPositions.forEach(pos => {
          if (pos.y > -25 - stemLength) {
            const thornGeometry = new THREE.ConeGeometry(1, 5, 6);
            const thorn = new THREE.Mesh(thornGeometry, thornMaterial);
            thorn.position.set(0, pos.y, 0);
            thorn.rotation.z = pos.rotZ;
            thorn.rotation.y = pos.rotY;
            const offset = 3;
            thorn.position.x += Math.sin(pos.rotY) * offset;
            thorn.position.z += Math.cos(pos.rotY) * offset;
            thorn.castShadow = true;
            stemGroup.add(thorn);
          }
        });

        return stemGroup;
      }

      // Bouquet configuration - positions roses in a natural arrangement
      // Increased spacing and tilt to prevent petal intersection
      const bouquetConfig = [
        // Center rose (tallest)
        { x: 0, z: 0, tiltX: 0, tiltZ: 0, rotY: 0, stemLength: 210, scale: 0.75 },
        
        // Inner ring (5 roses) - tilted outward more aggressively
        { x: 55, z: 0, tiltX: 0, tiltZ: -0.45, rotY: 0.5, stemLength: 195, scale: 0.7 },
        { x: 17, z: 52, tiltX: 0.45, tiltZ: -0.14, rotY: 1.2, stemLength: 188, scale: 0.68 },
        { x: -44, z: 32, tiltX: 0.38, tiltZ: 0.35, rotY: 2.1, stemLength: 203, scale: 0.72 },
        { x: -44, z: -32, tiltX: -0.38, tiltZ: 0.35, rotY: 3.0, stemLength: 192, scale: 0.69 },
        { x: 17, z: -52, tiltX: -0.45, tiltZ: -0.14, rotY: 4.0, stemLength: 198, scale: 0.71 },
        
        // Outer ring (6 roses) - longer stems to reach the edges
        { x: 95, z: 35, tiltX: 0.25, tiltZ: -0.65, rotY: 0.8, stemLength: 260, scale: 0.62 },
        { x: 50, z: 90, tiltX: 0.65, tiltZ: -0.3, rotY: 1.6, stemLength: 255, scale: 0.58 },
        { x: -40, z: 90, tiltX: 0.65, tiltZ: 0.25, rotY: 2.5, stemLength: 265, scale: 0.6 },
        { x: -90, z: 0, tiltX: 0, tiltZ: 0.65, rotY: 3.3, stemLength: 258, scale: 0.59 },
        { x: -40, z: -90, tiltX: -0.65, tiltZ: 0.25, rotY: 4.2, stemLength: 270, scale: 0.63 },
        { x: 50, z: -90, tiltX: -0.65, tiltZ: -0.3, rotY: 5.0, stemLength: 252, scale: 0.57 },
      ];

      // Create realistic red bow ribbon
      function createBowRibbon() {
        const bowGroup = new THREE.Group();
        
        const ribbonMaterial = new THREE.MeshStandardMaterial({
          color: 0xc41e3a,
          roughness: 0.45,
          metalness: 0.05,
          side: THREE.DoubleSide
        });

        // Helper function to create a ribbon loop using a curved path
        function createRibbonLoop(curvePoints, ribbonWidth, ribbonThickness) {
          const curve = new THREE.CatmullRomCurve3(curvePoints);
          
          const ribbonShape = new THREE.Shape();
          ribbonShape.moveTo(-ribbonWidth / 2, -ribbonThickness / 2);
          ribbonShape.lineTo(ribbonWidth / 2, -ribbonThickness / 2);
          ribbonShape.lineTo(ribbonWidth / 2, ribbonThickness / 2);
          ribbonShape.lineTo(-ribbonWidth / 2, ribbonThickness / 2);
          ribbonShape.lineTo(-ribbonWidth / 2, -ribbonThickness / 2);
          
          const extrudeSettings = {
            steps: 50,
            bevelEnabled: false,
            extrudePath: curve
          };
          
          return new THREE.ExtrudeGeometry(ribbonShape, extrudeSettings);
        }

        // Left loop - tighter, starting closer to center
        const leftLoopPoints = [
          new THREE.Vector3(-2, 0, 0),
          new THREE.Vector3(-12, 10, 4),
          new THREE.Vector3(-28, 16, 2),
          new THREE.Vector3(-32, 8, -1),
          new THREE.Vector3(-24, 0, -3),
          new THREE.Vector3(-12, -2, -1),
          new THREE.Vector3(-2, 0, 0)
        ];
        const leftLoopGeometry = createRibbonLoop(leftLoopPoints, 12, 1.5);
        const leftLoop = new THREE.Mesh(leftLoopGeometry, ribbonMaterial);
        bowGroup.add(leftLoop);

        // Right loop - tighter, starting closer to center
        const rightLoopPoints = [
          new THREE.Vector3(2, 0, 0),
          new THREE.Vector3(12, 10, 4),
          new THREE.Vector3(28, 16, 2),
          new THREE.Vector3(32, 8, -1),
          new THREE.Vector3(24, 0, -3),
          new THREE.Vector3(12, -2, -1),
          new THREE.Vector3(2, 0, 0)
        ];
        const rightLoopGeometry = createRibbonLoop(rightLoopPoints, 12, 1.5);
        const rightLoop = new THREE.Mesh(rightLoopGeometry, ribbonMaterial);
        bowGroup.add(rightLoop);

        // Small inner left loop - tighter
        const innerLeftPoints = [
          new THREE.Vector3(-1, 1, 1),
          new THREE.Vector3(-8, 12, 5),
          new THREE.Vector3(-16, 10, 3),
          new THREE.Vector3(-12, 2, 1),
          new THREE.Vector3(-1, 1, 1)
        ];
        const innerLeftGeometry = createRibbonLoop(innerLeftPoints, 10, 1.5);
        const innerLeftLoop = new THREE.Mesh(innerLeftGeometry, ribbonMaterial);
        bowGroup.add(innerLeftLoop);

        // Small inner right loop - tighter
        const innerRightPoints = [
          new THREE.Vector3(1, 1, 1),
          new THREE.Vector3(8, 12, 5),
          new THREE.Vector3(16, 10, 3),
          new THREE.Vector3(12, 2, 1),
          new THREE.Vector3(1, 1, 1)
        ];
        const innerRightGeometry = createRibbonLoop(innerRightPoints, 10, 1.5);
        const innerRightLoop = new THREE.Mesh(innerRightGeometry, ribbonMaterial);
        bowGroup.add(innerRightLoop);

        // Left tail - starting right from the knot
        const leftTailPoints = [
          new THREE.Vector3(-3, -1, 1),
          new THREE.Vector3(-10, -16, 3),
          new THREE.Vector3(-6, -32, -2),
          new THREE.Vector3(-14, -48, 2),
          new THREE.Vector3(-10, -60, 0)
        ];
        const leftTailGeometry = createRibbonLoop(leftTailPoints, 10, 1);
        const leftTail = new THREE.Mesh(leftTailGeometry, ribbonMaterial);
        bowGroup.add(leftTail);

        // Right tail - starting right from the knot
        const rightTailPoints = [
          new THREE.Vector3(3, -1, 1),
          new THREE.Vector3(8, -18, -2),
          new THREE.Vector3(12, -35, 3),
          new THREE.Vector3(6, -50, -1),
          new THREE.Vector3(12, -62, 1)
        ];
        const rightTailGeometry = createRibbonLoop(rightTailPoints, 10, 1);
        const rightTail = new THREE.Mesh(rightTailGeometry, ribbonMaterial);
        bowGroup.add(rightTail);

        // Center knot - larger to cover connections
        const knotGeometry = new THREE.SphereGeometry(9, 16, 12);
        const knot = new THREE.Mesh(knotGeometry, ribbonMaterial);
        knot.scale.set(1.1, 0.85, 0.95);
        knot.position.set(0, 2, 1);
        bowGroup.add(knot);

        return bowGroup;
      }

      let rosesLoaded = 0;
      const totalRoses = bouquetConfig.length;
      const bouquetGroup = new THREE.Group();

      // manager
      function loadModel() {
        object.traverse(function (child) {
          if (child.isMesh) {
            if (child.name == "rose") {
              material = material.clone();
              material.color.set("crimson");
            } else if (child.name == "calyx") {
              material = material.clone();
              material.color.set("#001a14");
            } else if (child.name == "leaf1" || child.name == "leaf2") {
              material = material.clone();
              material.color.set("#00331b");
            }
            child.material = material;
          }
        });
        
        // Create bouquet
        bouquetConfig.forEach((config, index) => {
          // Clone the rose
          const roseClone = object.clone();
          
          // Apply different shades of red for variety - true reds around DB0F0F/C70A0A
          const redVariations = [
            "#db0f0f", // base red
            "#c70a0a", // slightly darker
            "#e01010", // slightly brighter
            "#d10d0d", // medium
            "#cc0c0c", // darker
            "#e51212", // brighter
            "#c90b0b", // dark
            "#d80e0e", // medium bright
            "#d30d0d", // medium
            "#ce0c0c", // medium dark
            "#dc1010", // bright
            "#c50a0a", // darkest
          ];
          
          roseClone.traverse(function (child) {
            if (child.isMesh && child.name === "rose") {
              const newMaterial = child.material.clone();
              newMaterial.color.set(redVariations[index % redVariations.length]);
              child.material = newMaterial;
            }
          });
          
          // Create a group for this rose + stem
          const roseUnit = new THREE.Group();
          
          // Add the rose flower
          roseClone.rotation.set(0, Math.PI / 1.7 + config.rotY, 0);
          roseClone.scale.set(config.scale, config.scale, config.scale);
          roseClone.receiveShadow = true;
          roseClone.castShadow = true;
          roseUnit.add(roseClone);
          
          // Add stem
          const stem = createPedicle(config.stemLength);
          stem.rotation.set(0, Math.PI / 1.7 + config.rotY, 0);
          stem.scale.set(config.scale, config.scale, config.scale);
          roseUnit.add(stem);
          
          // Position and tilt the entire rose unit
          roseUnit.position.set(config.x, 0, config.z);
          roseUnit.rotation.x = config.tiltX;
          roseUnit.rotation.z = config.tiltZ;
          
          bouquetGroup.add(roseUnit);
        });
        
        scene.add(bouquetGroup);

        // Add the red bow ribbon where stems meet
        const bow = createBowRibbon();
        bow.position.set(0, -120, 0);
        scene.add(bow);
      }

      manager = new THREE.LoadingManager(loadModel);

      // model
      function onProgress(xhr) {
        if (xhr.lengthComputable) {
          const percentComplete = (xhr.loaded / xhr.total) * 100;
          console.log("Loading: " + Math.round(percentComplete) + "%");
        }
      }
      function onError(error) {
        console.error("Error loading model:", error);
      }

      const loader = new OBJLoader(manager);
      loader.load(
        "https://happy358.github.io/Images/Model/red_rose3.obj",
        function (obj) {
          object = obj;
        },
        onProgress,
        onError
      );

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit for mobile performance
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.shadowMap.enabled = true;
      container.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.autoRotate = true;
      controls.autoRotateSpeed = 1;
      controls.enableDamping = true;
      controls.enablePan = false;
      controls.minPolarAngle = 0;
      controls.maxPolarAngle = Math.PI * 0.85;
      controls.target.set(0, -40, 0);
      controls.touches = {
        ONE: THREE.TOUCH.ROTATE,
        TWO: THREE.TOUCH.DOLLY_PAN
      };
      controls.update();

      window.addEventListener("resize", onWindowResize);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      render();
    }

    function render() {
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
